#!/usr/bin/env python

"""
ChIP-seq pipeline
"""

from argparse import ArgumentParser
import os
import sys
from pipelines import toolkit as tk
import cPickle as pickle
from pypiper import Pypiper


__author__ = "Andre Rendeiro"
__copyright__ = "Copyright 2014, Andre Rendeiro"
__credits__ = []
__license__ = "GPL2"
__version__ = "0.1"
__maintainer__ = "Andre Rendeiro"
__email__ = "arendeiro@cemm.oeaw.ac.at"
__status__ = "Development"


def main():
    # Parse command-line arguments
    parser = ArgumentParser(description="ChIP-seq pipeline.")

    parser = mainArgParser(parser)

    # Parse
    args = parser.parse_args()
    samplePickle = args.samplePickle

    # Read in objects
    prj, sample, args = pickle.load(open(samplePickle, "rb"))
    # if doing the analysis part, require a tuple as "sample" and split it into sample and control
    if args.command == "analyse":
        if type(sample) is tuple:
            sample, ctrl = sample
        else:
            raise TypeError("For the 'analyse command, a tuple of (sample, control) must be passed as 2nd element in pickle.")

    # Start main function
    if args.command == "preprocess":
        preprocess(args, prj, sample)
    elif args.command == "analyse":
        analyse(args, prj, sample, ctrl)

    # Remove pickle
    if not args.dry_run:
        os.system("rm %s" % samplePickle)

    # Exit
    print("Finished and exiting.")

    sys.exit(0)


def mainArgParser(parser):
    """
    Global options for pipeline.
    """
    # Project
    parser.add_argument(
        dest="samplePickle",
        help="Pickle with tuple of: (pipelines.Project, pipelines.Sample, argparse.ArgumentParser).",
        type=str
    )
    return parser


def preprocess(args, prj, sample):
    """
    This takes unmapped Bam files and makes trimmed, aligned, duplicate marked
    and removed, indexed (and shifted if necessary) Bam files
    along with a UCSC browser track.
    """

    print("Starting sample preprocessing.")

    # Start Pypiper object
    pipe = Pypiper("pipe", sample.dirs.sampleRoot)

    # keep track of temporary files
    tempFiles = list()

    if args.stage in ["all"]:
        # if more than one technical replicate, merge bams
        if type(sample.unmappedBam) == list:
            cmd = tk.mergeBams(
                inputBams=sample.unmappedBam,  # this is a list of sample paths
                outputBam=sample.unmapped
            )
            pipe.call_lock(cmd, sample.unmapped)
            sample.unmappedBam = sample.unmapped
    if args.stage in ["all", "fastqc"]:
        # TODO:
        # Fastqc should be independent from this job but since there's no option in fastqc to specify
        # the sample name, I'll for now run it on the already renamed fastq file produced before,
        # which requires fastqc to run in the same job as the rest :S
        cmd = tk.fastqc(
            inputBam=sample.unmappedBam,
            outputDir=sample.dirs.sampleRoot
        )
        pipe.call_lock(cmd, sample.dirs.sampleRoot + sample.sampleName + ".zip")
    # convert bam to fastq
    if args.stage in ["all", "bam2fastq"]:
        if not sample.paired:
            cmd = tk.bam2fastq(
                inputBam=sample.unmappedBam,
                outputFastq=sample.fastq
            )
            pipe.call_lock(cmd, sample.fastq)
            tempFiles.append(sample.fastq)
        else:
            cmd = tk.bam2fastq(
                inputBam=sample.unmappedBam,
                outputFastq=sample.fastq1,
                outputFastq2=sample.fastq2,
                unpairedFastq=sample.fastqUnpaired
            )
            pipe.call_lock(cmd, sample.fastq1)
            tempFiles.append(sample.fastq1)
            tempFiles.append(sample.fastq2)
            tempFiles.append(sample.fastqUnpaired)

    if args.stage in ["all", "trim"]:
        # TODO:
        # Change absolute path to something usable by everyone or to an option.
        if args.trimmer == "trimmomatic":
            cmd = tk.trimmomatic(
                inputFastq1=sample.fastq1 if sample.paired else sample.fastq,
                inputFastq2=sample.fastq2 if sample.paired else None,
                outputFastq1=sample.trimmed1 if sample.paired else sample.trimmed,
                outputFastq1unpaired=sample.trimmed1Unpaired if sample.paired else None,
                outputFastq2=sample.trimmed2 if sample.paired else None,
                outputFastq2unpaired=sample.trimmed2Unpaired if sample.paired else None,
                cpus=args.cpus,
                adapters=prj.config["adapters"],
                log=sample.trimlog
            )
            pipe.call_lock(cmd, sample.trimmed1 if sample.paired else sample.trimmed)
            if not sample.paired:
                tempFiles.append(sample.fastq1)
            else:
                tempFiles.append(sample.trimmed1)
                tempFiles.append(sample.trimmed1Unpaired)
                tempFiles.append(sample.trimmed2)
                tempFiles.append(sample.trimmed2Unpaired)

        if args.trimmer == "skewer":
            cmd = tk.skewer(
                inputFastq1=sample.fastq1 if sample.paired else sample.fastq,
                inputFastq2=sample.fastq2 if sample.paired else None,
                outputPrefix=os.path.join(sample.dirs.unmapped, sample.sampleName),
                cpus=args.cpus,
                adapters=prj.config["adapters"]
            )
            pipe.call_lock(cmd, sample.sampleName + "-trimmed-pair1.fastq" if sample.paired else sample.sampleName + "-trimmed.fastq")
            # move files to have common name
            if not sample.paired:
                cmd = tk.moveFile(
                    os.path.join(sample.dirs.unmapped, sample.sampleName + "-trimmed.fastq"),
                    sample.trimmed
                )
                tempFiles.append(sample.trimmed)
            else:
                cmd = tk.moveFile(
                    os.path.join(sample.dirs.unmapped, sample.sampleName + "-trimmed-pair1.fastq"),
                    sample.trimmed1
                )
                cmd = tk.moveFile(
                    os.path.join(sample.dirs.unmapped, sample.sampleName + "-trimmed-pair2.fastq"),
                    sample.trimmed2
                )
                tempFiles.append(sample.trimmed1)
                tempFiles.append(sample.trimmed2)
            # move log to results dir
            cmd = tk.moveFile(
                os.path.join(sample.dirs.unmapped, sample.sampleName + "-trimmed.log"),
                sample.trimlog
            )

    if args.stage in ["all", "mapping"]:
        cmd = tk.bowtie2Map(
            inputFastq1=sample.trimmed1 if sample.paired else sample.trimmed,
            inputFastq2=sample.trimmed1 if sample.paired else None,
            outputBam=sample.mapped,
            log=sample.alnRates,
            metrics=sample.alnMetrics,
            genomeIndex=prj.config["annotations"]["genomes"][sample.genome],
            maxInsert=args.maxinsert,
            cpus=args.cpus
        )
        pipe.call_lock(cmd, sample.mapped)
        tempFiles.append(sample.mapped)
    if args.stage in ["all", "markduplicates"]:
        cmd = tk.markDuplicates(
            inputBam=sample.mapped,
            outputBam=sample.dups,
            metricsFile=sample.dupsMetrics
        )
        pipe.call_lock(cmd, sample.dups)
    if args.stage in ["all", "removeduplicates"]:
        cmd = tk.removeDuplicates(
            inputBam=sample.dups,
            outputBam=sample.nodups,
            cpus=args.cpus
        )
        pipe.call_lock(cmd, sample.nodups)
    if args.stage in ["all", "shiftreads"]:
        if sample.tagmented:
            cmd = tk.shiftReads(
                inputBam=sample.dups,
                genome=sample.genome,
                outputBam=sample.dupsshifted
            )
            pipe.call_lock(cmd, sample.dupsshifted)
            cmd = tk.shiftReads(
                inputBam=sample.nodups,
                genome=sample.genome,
                outputBam=sample.nodupsshifted
            )
            pipe.call_lock(cmd, sample.nodupsshifted)
    if args.stage in ["all", "indexbam"]:
        for s in [sample.dups, sample.nodups]:
            cmd = tk.indexBam(inputBam=s)
            pipe.call_lock(cmd, s + ".bai")
        if sample.tagmented:
            for s in [sample.dupsshifted, sample.nodupsshifted]:
                cmd = tk.indexBam(inputBam=s)
                pipe.call_lock(cmd, s + ".bai")

    if args.stage in ["all", "maketracks"]:
        # right now tracks are only made for bams without duplicates
        cmd = tk.bamToUCSC(
            inputBam=sample.nodups,
            outputBigWig=sample.bigwig,
            genomeSizes=prj.config["annotations"]["chrsizes"][sample.genome],
            genome=sample.genome,
            tagmented=sample.tagmented
        )
        pipe.call_lock(cmd, sample.bigwig)
        cmd = tk.addTrackToHub(
            sampleName=sample.sampleName,
            trackURL=sample.trackURL,
            trackHub=os.path.join(prj.dirs.html, "trackHub_{0}.txt".format(sample.genome)),
            colour=sample.trackColour
        )
        pipe.call_lock(cmd, shell=True)
        tk.linkToTrackHub(
            trackHubURL=os.path.join(prj.dirs.html, "trackHub_{0}.txt".format(sample.genome)),
            fileName=os.path.join(prj.dirs.root, "ucsc_tracks_{0}.html".format(sample.genome)),
            genome=sample.genome
        )
    if args.stage in ["all", "coverage"]:
        cmd = tk.genomeWideCoverage(
            inputBam=sample.nodups,
            genomeWindows=prj.config["annotations"]["genomewindows"][sample.genome],
            output=sample.coverage
        )
        pipe.call_lock(cmd, sample.coverage)

    # Remove intermediary files
    if args.stage == "all" and not args.keep_tmp:
        print("Removing intermediary files")
        for fileName in tempFiles:
            cmd = tk.removeFile(fileName)
            pipe.call_lock(cmd, shell=True)

    print("Finished preprocessing sample %s." % sample.sampleName)


def analyse(args, prj, sample, ctrl):
    """
    Perform ChIP-seq QC, call peaks, perform de novo motif discovery,
    plot signal around called peaks and TSSs.
    """
    print("Starting sample analysis.")

    # Start Pypiper object
    pipe = Pypiper("pipe", prj.dirs.logs + sample.sampleName)

    if args.stage in ["all", "qc"]:
        cmd = tk.peakTools(
            inputBam=sample.nodups,
            output=os.path.join(prj.dirs.qc, "sample_QC.tsv"),
            plot=os.path.join(prj.dirs.qc, sample.sampleName + "_QC.pdf"),
            cpus=args.cpus
        )
        pipe.call_lock(cmd, os.path.join(prj.dirs.qc, "sample_QC.tsv"))
    if args.stage in ["all", "callpeaks"]:
        if args.peak_caller == "macs2":
            # make dir for output
            if not os.path.exists(os.path.join(sample.dirs.peaks, sample.sampleName)):
                os.makedirs(os.path.join(sample.dirs.peaks, sample.sampleName))

            # For point-source factors use default settings
            # For broad factors use broad settings
            cmd = tk.macs2CallPeaks(
                treatmentBam=sample.nodups,
                controlBam=ctrl.nodups,
                outputDir=os.path.join(sample.dirs.peaks, sample.sampleName),
                sampleName=sample.sampleName,
                genome=sample.genome,
                broad=True if sample.broad else False
            )
            pipe.call_lock(cmd, sample.peaks)
        elif args.peak_caller == "spp":
            # For point-source factors use default settings
            # For broad factors use broad settings
            cmd = tk.sppCallPeaks(
                treatmentBam=sample.nodups,
                controlBam=ctrl.nodups,
                treatmentName=sample.sampleName,
                controlName=ctrl.sampleName,
                outputDir=os.path.join(sample.dirs.peaks, sample.sampleName),
                broad=True if sample.broad else False,
                cpus=args.cpus
            )
            pipe.call_lock(cmd, sample.peaks)
        elif args.peak_caller == "zinba":
            raise NotImplementedError("Calling peaks with Zinba is not yet implemented.")
            # cmd = tk.bamToBed(
            #     inputBam=sample.nodups,
            #     outputBed=os.path.join(sample.dirs.peaks, sample.sampleName + ".bed"),
            # )
            # pipe.call_lock(cmd, os.path.join(sample.dirs.peaks, sample.sampleName + ".bed"))
            # cmd = tk.bamToBed(
            #     inputBam=ctrl.nodups,
            #     outputBed=os.path.join(sample.dirs.peaks, control.sampleName + ".bed"),
            # )
            # pipe.call_lock(cmd, os.path.join(sample.dirs.peaks, control.sampleName + ".bed"))
            # cmd = tk.zinbaCallPeaks(
            #     treatmentBed=os.path.join(sample.dirs.peaks, sample.sampleName + ".bed"),
            #     controlBed=os.path.join(sample.dirs.peaks, control.sampleName + ".bed"),
            #     tagmented=sample.tagmented,
            #     cpus=args.cpus
            # )
            # pipe.call_lock(cmd)
    if args.stage in ["all", "findmotifs"]:
        if not sample.histone:
            # For TFs, find the "self" motif
            cmd = tk.homerFindMotifs(
                peakFile=sample.peaks,
                genome=sample.genome,
                outputDir=sample.motifsDir,
                size="50",
                length="8,10,12,14,16",
                n_motifs=8
            )
            pipe.call_lock(cmd, os.path.join(sample.motifsDir, "homerResults", "motif1.motif"))
            # For TFs, find co-binding motifs (broader region)
            cmd = tk.homerFindMotifs(
                peakFile=sample.peaks,
                genome=sample.genome,
                outputDir=sample.motifsDir + "_cobinders",
                size="200",
                length="8,10,12,14,16",
                n_motifs=12
            )
            pipe.call_lock(cmd, os.path.join(sample.motifsDir + "_cobinders", "homerResults", "motif1.motif"))
        else:
            # For histones, use a broader region to find motifs
            cmd = tk.homerFindMotifs(
                peakFile=sample.peaks,
                genome=sample.genome,
                outputDir=sample.motifsDir,
                size="1000",
                length="8,10,12,14,16",
                n_motifs=20
            )
            pipe.call_lock(cmd, os.path.join(sample.motifsDir, "homerResults", "motif1.motif"))
    if args.stage in ["all", "centerpeaks"]:
        # TODO:
        # right now this assumes peaks were called with MACS2
        # figure a way of magetting the peak files withough using the peak_caller option
        # for that would imply taht option would be required when selecting this stage
        cmd = tk.centerPeaksOnMotifs(
            peakFile=sample.peaks,
            genome=sample.genome,
            windowWidth=prj.config["options"]["peakwindowwidth"],
            motifFile=os.path.join(sample.motifsDir, "homerResults", "motif1.motif"),
            outputBed=sample.peaksMotifCentered
        )
        pipe.call_lock(cmd, sample.peaksMotifCentered)
    if args.stage in ["all", "annotatepeaks"]:
        # TODO:
        # right now this assumes peaks were called with MACS2
        # figure a way of getting the peak files withough using the peak_caller option
        # for that would imply taht option would be required when selecting this stage
        cmd = tk.AnnotatePeaks(
            peakFile=sample.peaks,
            genome=sample.genome,
            motifFile=os.path.join(sample.motifsDir, "homerResults", "motif1.motif"),
            outputBed=sample.peaksMotifAnnotated
        )
        pipe.call_lock(cmd, sample.peaksMotifAnnotated)
    if args.stage in ["all", "peakanalysis"]:
        cmd = tk.peakAnalysis(
            inputBam=sample.nodups,
            peakFile=sample.peaksMotifCentered,
            plotsDir=os.path.join(prj.dirs.results, 'plots'),
            windowWidth=prj.config["options"]["peakwindowwidth"],
            fragmentsize=1 if sample.tagmented else sample.readLength,
            genome=sample.genome,
            n_clusters=5,
            strand_specific=True,
            duplicates=True
        )
        pipe.call_lock(cmd)
    if args.stage in ["all", "tssanalysis"]:
        cmd = tk.tssAnalysis(
            inputBam=sample.nodups,
            tssFile=prj.config["annotations"]["tss"][sample.genome],
            plotsDir=os.path.join(prj.dirs.results, 'plots'),
            windowWidth=prj.config["options"]["peakwindowwidth"],
            fragmentsize=1 if sample.tagmented else sample.readLength,
            genome=sample.genome,
            n_clusters=5,
            strand_specific=True,
            duplicates=True
        )
        pipe.call_lock(cmd)
    if args.stage in ["all", "frip"]:
        cmd = tk.calculateFRiP(
            inputBam=sample.nodups,
            inputBed=sample.peaks,
            output=sample.frip
        )
        pipe.call_lock(cmd, sample.frip, shell=True)

    # if args.stage in ["all", "footprints"] and control and sample.tagmented:
    #     cmd = tk.footprintAnalysis(
    #         sample.dirs.peaks, sample.sampleName, sample.sampleName + "_peaks.motifCentered.bed"),
    #         sample.dirs.peaks, sample.sampleName, sample.sampleName + "_peaks.motifAnnotated.bed")
    #     )
    #     pipe.call_lock(cmd)

    print("Finished analysis")


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("Program canceled by user!")
        sys.exit(1)
